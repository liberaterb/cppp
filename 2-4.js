window["2-4"] = `

# 2.4　const限定符

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定：

~~~cpp
const int bufSize = 512;   // 输入缓冲区大小
~~~

这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误：

~~~cpp
bufSize = 512;             // 错误：试图向const对象写值
~~~

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式：

~~~cpp
const int i = get_size();  // 正确：运行时初始化
const int j = 42;          // 正确：编译时初始化
const int k;               // 错误：k是一个未经初始化的常量
~~~

### 初始化和const
正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是只能在const类型的对象上执行不改变其内容的操作。例如，const int和普通的int一样都能参与算术运算，也都能转换成一个布尔值，等等。

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：

~~~cpp
int i = 42;
const int ci = i;          // 正确：i的值被拷贝给了ci
int j = ci;                // 正确：ci的值被拷贝给了j
~~~

尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。

### 默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：

~~~cpp
const int bufSize = 512;   // 输入缓冲区大小
~~~

编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：

~~~cpp
// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h 头文件
extern const int bufSize;  // 与file_1.cc中定义的bufSize是同一个
~~~

如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。

file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

## 2.4.1　const的引用

`