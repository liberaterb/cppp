<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="md"></div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.4.0/styles/idea.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        document.getElementById('md').innerHTML =
            marked.parse(`

# 2.3　复合类型
          
**复合类型**（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：引用和指针。

与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。2.2节（第38页）提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个**基本数据类型**（base type）和紧随其后的一个**声明符**（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就是声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

## 2.3.1　引用
> C++11中新增了一种引用：所谓的“右值引用（rvalue reference）”，我们将在13.6.1节（第471页）做更详细的介绍。这种引用主要用于内置类。严格来说，当我们使用术语“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

~~~cpp
int ival = 1024;
int &refVal = ival;  // refVal指向ival（是ival的另一个名字）
int &refVal2;        // 报错：引用必须被初始化
~~~

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定**（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

**引用即别名**

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

~~~cpp
refVal = 2;      // 把 2 赋给 refVal 指向的对象，此处即是赋给了 ival
int ii = refVal; // 与 ii = ival 执行结果一样
~~~

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：

~~~cpp
// 正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上
int &refVal3 = refVal;
// 利用与refVal绑定的对象的值初始化变量i
int i = refVal; // 正确：i被初始化为ival的值
~~~

因为引用本身不是一个对象，所以不能定义引用的引用。

**引用的定义**

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头：

~~~cpp
int i = 1024, i2 = 2048; // i 和 i2 都是int
int &r = i; r2 = i2;     // r 是一个引用，与 i 绑定到一起，r2 是 int
int i3 = 1024, &ri = i3; // i3 是 int，ri 是一个引用，与 i3 绑定到一起
int &r3 = i3, &r4 = i3;  // r3 和 r4 都是引用
~~~

除了2.4.1节（第55页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起，相关原因将在2.4.1节详述：

~~~cpp
int &refVal4 = 10;    // 错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;  // 错误：此处引用类型的初始值必须是 int 型对象
~~~

2.3.2　指针

**指针**（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如
果没有被初始化，也将拥有一个不确定的值。

> 指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而被备受折磨。

定义指针类型的方法将声明符写成＊d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号＊：

~~~cpp
int *ip1, *ip2;  // ip1 和 ip2 都是指向 int 型对象的指针
double dp, *dp2; // dp2 是指向 double 型对象的指针，dp是 double 型对象
~~~

**获取对象的地址**

指针存放某个对象的地址，要想获取该地址，需要使用**取地址符**（操作符&）：

~~~cpp
int ival = 42;
int *p = &ival;  // p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针
~~~

第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：

~~~cpp
double dval;
double *pd = &dval;  // 正确：初始值是 double 型对象的地址
double *pd2 = pd;    // 正确：初始值是指向 double 对象的指针

int *pi = pd;        // 错误：指针 pi 的类型和 pd 的类型不匹配
pi = &dval;          // 错误：试图把 double 型对象的地址赋给 int 型指针
~~~

因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

**指针值**

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。

**利用指针访问对象**

如果指针指向了一个对象，则允许使用**解引用符**（操作符＊）来访问该对象：

~~~cpp
int ival = 42;
int *p = &val;  // p 存放着变量 ival 的地址，或者说 p 是指向变量 ival 的指针
cout << *p;     // 由符号 * 得到指针 p 所指的对象，输出 42 
~~~

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

~~~cpp
*p = 0;     // 由符号 * 得到指针p所指的对象，即可经由 p 为变量 ival 赋值
cout << *p; // 输出 0
~~~

如上述程序所示，为＊p赋值实际上是为p所指的对象赋值。

> 解引用操作仅适用于那些确实指向了某个对象的有效指针。

> **关键概念：某些符号有多重含义**
>
>像&和＊这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：
>~~~
int i = 42;
int &r = i;    // & 紧随类型名出现，因此是声明的一部分，r 是一个引用
int *p;        // * 紧随类型名出现，因此是声明的一部分，p 是一个指针
p = &i;        // & 出现在表达式中，是一个取地址符
*p = i;        // * 出现在表达式中，是一个解引用符
int &r2 = *p;  // & 是声明的一部分，* 是一个解引用符
>~~~
>在声明语句中，&和＊用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。空指针空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：
          


`);
    </script>
</body>

</html>